// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
package org.usfirst.frc2974.Walton2013.commands;

import edu.wpi.first.wpilibj.Timer;
import org.usfirst.frc2974.Walton2013.CamNetworkTable;
import org.usfirst.frc2974.Walton2013.Robot;

/**
 *
 */
public class UseDrive extends CommandBase {

    private boolean driverControl;
    private double myAngle;
    private double halfRange = 20;
    private double highAuto, lowAuto;
    private boolean distCentered = false, lrCentered = false;

    public UseDrive(boolean isDriverControlled) {//, double angleToReach) {
        requires(drive);
        requires(daGyro);
        if (CommandBase.oi.ds.isAutonomous()) {
            requires(shooter);
        }
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        System.out.println("use drive constructor"); //prints stuff
        //Set variables
        driverControl = isDriverControlled;
        //myAngle = angleToReach;
        highAuto = myAngle + 20;
        lowAuto = myAngle - 20;
        //  goingStraight = shouldGoStraight;
    }

    // Called just before this Command runs the first time
    protected void initialize() {
    }

    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
        //  System.out.println("***DRIVE EXECUTE***"); //print stuffs
        if (!CommandBase.oi.ds.isAutonomous()) {//!CommandBase.oi.ds.isAutonomous()) {
            if (oi.rightJoystick.getRawButton(2)) {
                drive.setSpeeds(getAutoForwardVal(), getAutoCenterVal(), 0);
            } else if (oi.rightJoystick.getRawButton(4)) {
                drive.setSpeeds(getAutoForwardVal(), getAutoSideVal(), 0);
            } //        else if (oi.rightJoystick.getRawButton(5)) {
            //            drive.setSpeeds(getAutoForwardVal(), getAutoRightVal(), 0);
            //        } //        else if (oi.rightJoystick.getRawButton(5)) {
            //            double[] instructions = getMovementInstructions(2.0); //get what the driver is telling the robot to do
            //            drive.setSpeeds(instructions[0], getMovingAutoVal(), instructions[2]); //sets drive train speeds to driver commands and auto aims
            //        } 
            else {
                double[] instructions = getMovementInstructions(2.0); //get what the driver is telling the robot to do
                drive.setSpeeds(instructions[0], instructions[1], instructions[2]); //sets drive train speeds to driver commands
            }
        } else {
            moveAround();
        }
        //System.out.println("***DRIVE EXECUTE***"); //print stuffs
//        } else { //if in autonomus
//            //System.out.println("DRIVE AUTO");
//            moveAround();
//        }
    }

    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
        return CommandBase.oi.ds.isAutonomous();
    }

    // Called once after isFinished returns true
    protected void end() {
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
    }

    /**
     * According to last year's code, the default number should be 2. otherwise,
     * just input a different modifier to slow down the movement, in theory
     * (untested as of 1-18-2013)
     */
    private void moveAround() {
        if (!distCentered || !lrCentered) {
            if (!distCentered) {
                drive.setSpeeds(getAutomonousForwardVal(), 0, 0);
                Timer.delay(1);
                System.out.println("Aiming distance....");
            } else { //dist is centered
                drive.setSpeeds(0, getAutoCenterVal(), 0);
                Timer.delay(1);
                System.out.println("Aiming left/right....");
            }
        } else {
            CommandBase.shooter.automonousShooting(true);
            System.out.println("Shooting....");
            Timer.delay(.2);
            do {
                CommandBase.shooter.automonousShooting(false);
                System.out.println("Waiting for circle....");
            } while (CommandBase.shooter.sensorPushed());
            System.out.println("Timer waiting....");
            Timer.delay(1);
        }
        System.out.println("Exiting....");
    }

    public double getAutomonousForwardVal() {
        //240 is center
        distCentered = false;
        double yCoor = CamNetworkTable.y;
        if (yCoor > 255) { //target's on the right
            // System.out.println("Going...");
            if (yCoor < 260) {
                return .3;
            } else {
                return .5;
            }
        } else if (yCoor < 225) { //target's on the left
            // System.out.println("Going...");
            if (yCoor > 220) {
                return -.3;
            } else {
                return -.5;
            }
        } else {
            distCentered = true;
            // System.out.println("Target Locked");
            return 0;
        }
    }

//    public double getAutomonousCenterVal() { //DONE **********************************
//        double xCoor = CamNetworkTable.x;
//        lrCentered = false;
//        if (xCoor > 332) { //target's on the right
//            //System.out.println("Going...");
//            if (xCoor < 550) {
//                return -.2;
//            } else {
//                return -.4;
//            }
//        } else if (xCoor < 232) { //target's on the left
//            //System.out.println("Going...");
//            if (xCoor > 100) {
//                return .2;
//            } else {
//                return .4;
//            }
//        } else {
//            //System.out.println("Target Locked");
//            lrCentered = true;
//            return 0;
//        }
//    }

    private double[] getMovementInstructions(double modifier) {
        //System.out.println("get movement instructions");
        double[] movementInstructions = new double[3];

        double forward = (oi.getLeftY() + oi.getRightY()) / modifier;
        double turn = (oi.getLeftY() - oi.getRightY()) / modifier;
        double strafe = -(oi.getLeftX() + oi.getRightX()) / modifier;
        movementInstructions[0] = forward;
        movementInstructions[1] = turn;
        movementInstructions[2] = strafe;

        return movementInstructions;
    }

    public double getAutoCenterVal() { //DONE **********************************
        double xCoor = CamNetworkTable.x;
        lrCentered = false;
        if (xCoor > 332) { //target's on the right
            //System.out.println("Going...");
            if (xCoor < 550) {
                return -.2;
            } else {
                return -.4;
            }
        } else if (xCoor < 232) { //target's on the left
            //System.out.println("Going...");
            if (xCoor > 100) {
                return .2;
            } else {
                return .4;
            }
        } else {
            lrCentered = true;
            //System.out.println("Target Locked");
            return 0;
        }
    }

    public double getAutoSideVal() {
        //x = 285, 327 max left 236 max right
        double xCoor = CamNetworkTable.x;
        if (xCoor > 290) { //target's on the right
            //System.out.println("Going...");
            return -.2;
//            if (xCoor < 330) {
//                return -.2;
//            } else {
//                return -.4;
//            }
        } else if (xCoor < 230) { //target's on the left
            //System.out.println("Going...");
            return .2;
//            if (xCoor > 260) {
//                return .2;
//            } else {
//                return .4;
//            }
        } else {
            //System.out.println("Target Locked");
            return 0;
        }
    }

    public double getAutoForwardVal() {
        //240 is center
        double yCoor = CamNetworkTable.y;
        if (yCoor > 255) { //target's on the right
            // System.out.println("Going...");
            if (yCoor < 260) {
                return .3;
            } else {
                return .5;
            }
        } else if (yCoor < 225) { //target's on the left
            // System.out.println("Going...");
            if (yCoor > 220) {
                return -.3;
            } else {
                return -.5;
            }
        } else {
            // System.out.println("Target Locked");
            return 0;
        }
    }
}
//    public double getMovingAutoVal() {
//        double xCoor = CamNetworkTable.x;
//        if (xCoor > 320) { //target's on the right
//            if (xCoor < 350) {
//                return -.2;
//            } else {
//                return -.1;
//            }
//        } else {
//            if (xCoor < 290) {
//                return .2;
//            } else {
//                return .1;
//            }
//        }
//    }
//******************************************************************************
// protected void execute() {
//        //  System.out.println("***DRIVE EXECUTE***"); //print stuffs
//        if (oi.rightJoystick.getRawButton(2)) {
//            drive.setSpeeds(getAutoForwardVal(), getAutoTurnVal(), 0);
//        } 
////        else if (oi.rightJoystick.getRawButton(5)) {
//        //            double[] instructions = getMovementInstructions(2.0); //get what the driver is telling the robot to do
//        //            drive.setSpeeds(instructions[0], getMovingAutoVal(), instructions[2]); //sets drive train speeds to driver commands and auto aims
//        //        } 
//        else {
//            double[] instructions = getMovementInstructions(2.0); //get what the driver is telling the robot to do
//            drive.setSpeeds(instructions[0], instructions[1], instructions[2]); //sets drive train speeds to driver commands
//        }
//        //System.out.println("***DRIVE EXECUTE***"); //print stuffs
////        } else { //if in autonomus
////            //System.out.println("DRIVE AUTO");
////            moveAround();
////        }
//    }
//******************************************************************************
//    public double getAutoRightVal() {
//        // x = 285
//        double xCoor = CamNetworkTable.x;
//        if (xCoor > 365) { //target's on the right
//            //System.out.println("Going...");
//            if (xCoor < 550) {
//                return -.2;
//            } else {
//                return -.4;
//            }
//        } else if (xCoor < 245) { //target's on the left
//            //System.out.println("Going...");
//            if (xCoor > 100) {
//                return .2;
//            } else {
//                return .4;
//            }
//        } else {
//            //System.out.println("Target Locked");
//            return 0;
//        }
//    }
//******************************************************************************
//        if (!oi.autoFinished) {
//            if (!(daGyro.getAngle() < (highAuto) && daGyro.getAngle() > (lowAuto))) { //if robot not centered
//                if (daGyro.getAngle() < lowAuto) { //if robot < the desired angle - half the dead range
//                    //System.out.println("Less than angle " + daGyro.getAngle() + ". \n " + (myAngle - 20)); //prints stuffs
//                    drive.setSpeeds(0, -.5, 0); //turns in the direction to the desired angle
//                } else if (daGyro.getAngle() > highAuto) { //if robot > the desired angle + half the dead range
//                    //System.out.println("Greater than angle " + daGyro.getAngle() + ". \n " + (myAngle + 20)); //prints stuffs
//                    drive.setSpeeds(0, .5, 0); //turns in the direction to the desired angle
//                } else {
//                    //STOP
//                    System.out.println("STOPPED AND EXPLODING: moveAround() in UseDrive"); //prints stuffs
//                }
//            } else {
//                drive.setSpeeds(0, 0, 0); //stop the robot
//                Timer.delay(1);
//                drive.setSpeeds(-1, 0, 0); //go full forward(yes, negative is forward
//                Timer.delay(1); //wait two seconds
//                drive.setSpeeds(0, 0, 0); //stop the robot
//                oi.setAutoEnd(true);
//            }
//        }