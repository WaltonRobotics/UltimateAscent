// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
package org.usfirst.frc2974.Walton2013.subsystems;

import edu.wpi.first.wpilibj.AnalogChannel;
import edu.wpi.first.wpilibj.CANJaguar;
import edu.wpi.first.wpilibj.Relay;
import edu.wpi.first.wpilibj.Talon;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.can.CANTimeoutException;
import edu.wpi.first.wpilibj.command.Subsystem;
import org.usfirst.frc2974.Walton2013.RobotMap;
import org.usfirst.frc2974.Walton2013.commands.AimAndShoot;

/**
 *
 */
public class ShooterSystem extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    CANJaguar shooterJag = RobotMap.shootershooterJag;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    Talon elevate = RobotMap.elevateTalon;
    Relay loader = RobotMap.loadSpike;
    AnalogChannel potentiometer = new AnalogChannel(RobotMap.potentiometer);
    private final double MAX_DEGREES = 30.0;
    private final double MIN_DEGREES = 1.0;
    private final double MAX_VOLTAGE = 0.0;
    private final double MIN_VOLTAGE = 1.0;
    private long pusherDelay = 1;
    //degreeFromVoltage is the calculated value of one degree when given the
    //above final values.  This is convienient because it allows us to not
    //calculate the same variable every time the current angle of the shooter
    //is calculated.
    private final double degreeFromVoltage =
            (MAX_VOLTAGE - MIN_VOLTAGE) / (MAX_DEGREES / MIN_DEGREES);
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        setDefaultCommand(new AimAndShoot()); //driver cont, 0 angle, half wheel, don't shoot
    }

    public void spinUpWheel(double speed) {
        try {
            //turn on wheel
            shooterJag.setX(speed);
        } catch (CANTimeoutException ex) {
            ex.printStackTrace();
        }
    }

    public boolean isWheelToSpeed() {
        try {
            //check if the shooter wheel is up to full speed
            if (Math.abs(shooterJag.getSpeed() - 1) < 0.0001) {
                return true;
            }
        } catch (CANTimeoutException ex) {
            ex.printStackTrace();
        }
        return false;
    }

    public void SHOOT() /*throws InterruptedException*/ { //shoot a frisbee
        //Display "BAM!" for fun(?)
        //@Michael from @Rishi: "Not a priority Michael"

        if (isWheelToSpeed()) {
            /* @Rishi
             add code using the "pusher" Talon
             ex.*/
            loader.set(Relay.Value.kForward);
            Timer.delay(pusherDelay);
            loader.set(Relay.Value.kReverse);
            Timer.delay(pusherDelay);
            loader.set(Relay.Value.kOff);
        }
    }

    public void putAngleUp() { //put shooter angle up
        if (getCurrentAngle() < MAX_DEGREES) {
            elevate.set(.33);//Lower rate of change to give more reaction time
        }        //To stop the motor at a desired level;

        /*
         * @Rishi alternate method with double parameter to adjust sensitivity
         * putAngleUp(double change)
         *elevate.set(getCurrentAngle()+change);
         */
    }

    public void putAngleDown() { //put shooter angle down
        if (getCurrentAngle() > MIN_DEGREES) {
            elevate.set(-.33);//Lower rate of change to give more reaction time
        }        //To stop the motor at a desired level;

        /*
         * @Rishi alternate method with double parameter to adjust sensitivity
         *putAngleDown(double change)
         *elevate.set(getCurrentAngle()-change);
         */
    }

    public void stopChangingAngle() { //stop changing angle of shooter
        elevate.set(0);
    }

    public double getCurrentAngle() {
        double inVoltage = potentiometer.getVoltage();
        double currentDegrees = inVoltage / degreeFromVoltage;
        return currentDegrees;
    }
    // public void setAngle(double angle) { //set the shooter angle to "angle"; change to work
    //Correct below code when more information comes in regarding the angle
    //Calculations
        /*   if(!elevate.isAlive){
     *      elevate.enable;
     *   }
     * 
     *   if(currentAngle < angle){
     *      putAngleUp();
     *      while(currentAngle < angle){
     *          currentAngle = getCurrentAngle();
     *          stopChangingAngle();
     *      }
     *   }else if(currentAngle > angle && !(angle < 0)){
     *      putAngleDown();
     *      while(currentAngle < angle){
     *          currentAngle = getCurrentAngle();
     *          stopChangingAngle()
     *      }
     *   }else{
     *      [Insert Message here to display onto dashboard]
     *  }
     * 
     */
    //}
}
